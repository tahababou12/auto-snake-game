var f=Object.defineProperty;var m=(r,t,s)=>t in r?f(r,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):r[t]=s;var a=(r,t,s)=>m(r,typeof t!="symbol"?t+"":t,s);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))e(i);new MutationObserver(i=>{for(const n of i)if(n.type==="childList")for(const h of n.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&e(h)}).observe(document,{childList:!0,subtree:!0});function s(i){const n={};return i.integrity&&(n.integrity=i.integrity),i.referrerPolicy&&(n.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?n.credentials="include":i.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function e(i){if(i.ep)return;i.ep=!0;const n=s(i);fetch(i.href,n)}})();class o{constructor(t,s){this.x=t,this.y=s}add(t){return new o(this.x+t.x,this.y+t.y)}subtract(t){return new o(this.x-t.x,this.y-t.y)}multiply(t){return new o(this.x*t,this.y*t)}normalize(){const t=Math.sqrt(this.x*this.x+this.y*this.y);return t===0?new o(0,0):new o(this.x/t,this.y/t)}distance(t){const s=this.x-t.x,e=this.y-t.y;return Math.sqrt(s*s+e*e)}clone(){return new o(this.x,this.y)}lerp(t,s){return new o(this.x+(t.x-this.x)*s,this.y+(t.y-this.y)*s)}}class p{constructor(t,s,e){a(this,"segments",[]);a(this,"velocity",new o(.2,0));a(this,"targetDirection",new o(.2,0));a(this,"speed",.2);a(this,"growing",0);a(this,"score",0);a(this,"initialLength",5);this.color=s,this.game=e,this.reset(t)}reset(t){if(!t){const s=this.game.getCanvas();t=new o(Math.random()*(s.width-100)+50,Math.random()*(s.height-100)+50)}this.segments=[];for(let s=0;s<this.initialLength;s++)this.segments.push(t.clone());this.velocity=new o(this.speed,0),this.targetDirection=this.velocity.clone(),this.score=0}update(t){this.think();const s=this.velocity.multiply(t),e=this.segments[0].add(s);this.segments.unshift(e),this.growing>0?this.growing--:this.segments.pop()}think(){const t=this.getHead(),s=this.game.getFoods(),e=this.game.getSnakes().filter(h=>h!==this);let i=s[0],n=1/0;if(s.forEach(h=>{const c=h.position.distance(t);c<n&&(n=c,i=h)}),i){const h=i.position.subtract(t).normalize(),c=t.add(h.multiply(20));let l=!1;const d=this.game.getCanvas();(c.x<10||c.x>d.width-10||c.y<10||c.y>d.height-10)&&(l=!0),e.forEach(g=>{g.segments.forEach(u=>{u.distance(c)<20&&(l=!0)})}),l?this.targetDirection=new o(Math.cos(Math.random()*Math.PI*2),Math.sin(Math.random()*Math.PI*2)):this.targetDirection=h}this.velocity=this.velocity.lerp(this.targetDirection,.1).normalize().multiply(this.speed)}render(t){t.fillStyle=this.color,this.segments.forEach((s,e)=>{const i=e===0?15:12;t.beginPath(),t.arc(s.x,s.y,i,0,Math.PI*2),t.fill()})}grow(){this.growing+=3,this.score+=10}getHead(){return this.segments[0]}checkWallCollision(t,s){const e=this.getHead();return e.x<0||e.x>t||e.y<0||e.y>s}checkSnakeCollision(t){const s=this.getHead();return t.segments.some(e=>e.distance(s)<12)}getLength(){return this.segments.length}getScore(){return this.score}}class y{constructor(t){this.position=t}render(t){t.fillStyle="#FF4444",t.beginPath(),t.arc(this.position.x,this.position.y,8,0,Math.PI*2),t.fill()}}class v{constructor(t,s,e){a(this,"canvas");a(this,"ctx");a(this,"snakes",[]);a(this,"foods",[]);a(this,"lastTime",0);a(this,"running",!1);this.canvas=document.getElementById(t),this.ctx=this.canvas.getContext("2d"),this.canvas.width=s,this.canvas.height=e;const i=["#FF0000","#00FF00","#0000FF","#FFFF00"];for(let n=0;n<4;n++){const h=new o(Math.random()*(s-100)+50,Math.random()*(e-100)+50);this.snakes.push(new p(h,i[n],this))}for(let n=0;n<10;n++)this.addFood()}start(){this.running=!0,requestAnimationFrame(this.gameLoop.bind(this))}gameLoop(t){const s=t-this.lastTime;this.lastTime=t,this.update(s),this.render(),this.running&&requestAnimationFrame(this.gameLoop.bind(this))}update(t){for(this.snakes.forEach(s=>s.update(t)),this.checkCollisions();this.foods.length<10;)this.addFood();this.updateStats()}render(){this.ctx.fillStyle="#1a1a1a",this.ctx.fillRect(0,0,this.canvas.width,this.canvas.height),this.foods.forEach(t=>t.render(this.ctx)),this.snakes.forEach(t=>t.render(this.ctx))}checkCollisions(){this.snakes.forEach(t=>{this.foods=this.foods.filter(s=>s.position.distance(t.getHead())<15?(t.grow(),!1):!0)}),this.snakes.forEach(t=>{t.checkWallCollision(this.canvas.width,this.canvas.height)&&t.reset(),this.snakes.forEach(s=>{t!==s&&t.checkSnakeCollision(s)&&t.reset()})})}addFood(){const t=new o(Math.random()*(this.canvas.width-20)+10,Math.random()*(this.canvas.height-20)+10);this.foods.push(new y(t))}updateStats(){const t=document.getElementById("snakeStats");t&&(t.innerHTML=this.snakes.map((s,e)=>`
          <div class="snake-stat" style="color: ${s.color}">
            Snake ${e+1}: Length ${s.getLength()} | Score ${s.getScore()}
          </div>
        `).join(""))}getFoods(){return this.foods}getSnakes(){return this.snakes}getCanvas(){return{width:this.canvas.width,height:this.canvas.height}}}const w=document.querySelector("#app");w.innerHTML=`
  <div class="game-container">
    <canvas id="gameCanvas"></canvas>
    <div class="stats">
      <h2>Battle Stats</h2>
      <div id="snakeStats"></div>
    </div>
  </div>
`;const x=new v("gameCanvas",800,600);x.start();
